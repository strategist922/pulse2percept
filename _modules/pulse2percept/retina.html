

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pulse2percept.retina &mdash; pulse2percept 0.2.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="pulse2percept 0.2.0 documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> pulse2percept
          

          
          </a>

          
            
            
              <div class="version">
                0.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../reference/index.html">API Reference</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">pulse2percept</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>pulse2percept.retina</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pulse2percept.retina</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.special</span> <span class="k">as</span> <span class="nn">ss</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">from</span> <span class="nn">pulse2percept</span> <span class="k">import</span> <span class="n">utils</span>


<span class="n">SUPPORTED_LAYERS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;INL&#39;</span><span class="p">,</span> <span class="s1">&#39;GCL&#39;</span><span class="p">,</span> <span class="s1">&#39;OFL&#39;</span><span class="p">]</span>
<span class="n">SUPPORTED_MODELS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;latest&#39;</span><span class="p">,</span> <span class="s1">&#39;Nanduri2012&#39;</span><span class="p">,</span> <span class="s1">&#39;Horsager2009&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="Grid"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.Grid">[docs]</a><span class="k">class</span> <span class="nc">Grid</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent the retinal coordinate frame&quot;&quot;&quot;</span>

<div class="viewcode-block" id="Grid.__init__"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.Grid.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xlo</span><span class="o">=-</span><span class="mi">1000</span><span class="p">,</span> <span class="n">xhi</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">ylo</span><span class="o">=-</span><span class="mi">1000</span><span class="p">,</span> <span class="n">yhi</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                 <span class="n">sampling</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">axon_lambda</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">rot</span><span class="o">=</span><span class="mi">0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">,</span>
                 <span class="n">datapath</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">save_data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generates a spatial grid representing the retinal coordinate frame</span>

<span class="sd">        This function generates the coordinate system for the retina</span>
<span class="sd">        and an axon map. As this can take a while, the function will</span>
<span class="sd">        first look for an already existing file in the directory `datapath`</span>
<span class="sd">        that was automatically created from an earlier call to this function,</span>
<span class="sd">        before it attempts to generate new grid from scratch.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xlo, xhi : float</span>
<span class="sd">           Extent of the retinal coverage (microns) in horizontal dimension.</span>
<span class="sd">           Default: xlo=-1000, xhi=1000.</span>
<span class="sd">        ylo, yhi : float</span>
<span class="sd">           Extent of the retinal coverage (microns) in vertical dimension.</span>
<span class="sd">           Default: ylo=-1000, ylo=1000.</span>
<span class="sd">        datapath : str</span>
<span class="sd">            Relative path where to look for existing retina files, and where to</span>
<span class="sd">            store new files. Default: current directory.</span>
<span class="sd">        save_data : bool</span>
<span class="sd">            Flag whether to save the data to a new file (True) or not (False).</span>
<span class="sd">            The file name is automatically generated from all specified input</span>
<span class="sd">            arguments.</span>
<span class="sd">            Default: True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Include endpoints in meshgrid</span>
        <span class="n">num_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">xhi</span> <span class="o">-</span> <span class="n">xlo</span><span class="p">)</span> <span class="o">/</span> <span class="n">sampling</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">num_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">yhi</span> <span class="o">-</span> <span class="n">ylo</span><span class="p">)</span> <span class="o">/</span> <span class="n">sampling</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gridx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xlo</span><span class="p">,</span> <span class="n">xhi</span><span class="p">,</span> <span class="n">num_x</span><span class="p">),</span>
                                             <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">ylo</span><span class="p">,</span> <span class="n">yhi</span><span class="p">,</span> <span class="n">num_y</span><span class="p">),</span>
                                             <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">)</span>

        <span class="c1"># Create descriptive filename based on input args</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;retina_s</span><span class="si">%d</span><span class="s2">_l</span><span class="si">%.1f</span><span class="s2">_rot</span><span class="si">%.1f</span><span class="s2">_</span><span class="si">%d</span><span class="s2">x</span><span class="si">%d</span><span class="s2">.npz&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sampling</span><span class="p">,</span>
                                                           <span class="n">axon_lambda</span><span class="p">,</span>
                                                           <span class="n">rot</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">180</span><span class="p">,</span>
                                                           <span class="n">xhi</span> <span class="o">-</span> <span class="n">xlo</span><span class="p">,</span>
                                                           <span class="n">yhi</span> <span class="o">-</span> <span class="n">ylo</span><span class="p">)</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">datapath</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

        <span class="c1"># Bool whether we need to create a new grid</span>
        <span class="n">need_new_grid</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Check if such a file already exists. If so, load parameters and</span>
        <span class="c1"># make sure they are the same as specified above. Else, create new.</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
            <span class="n">need_new_grid</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">axon_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

            <span class="c1"># Verify that the file was created with a consistent grid:</span>
            <span class="n">ax_id</span> <span class="o">=</span> <span class="n">axon_map</span><span class="p">[</span><span class="s1">&#39;axon_id&#39;</span><span class="p">]</span>
            <span class="n">ax_wt</span> <span class="o">=</span> <span class="n">axon_map</span><span class="p">[</span><span class="s1">&#39;axon_weight&#39;</span><span class="p">]</span>
            <span class="n">xlo_am</span> <span class="o">=</span> <span class="n">axon_map</span><span class="p">[</span><span class="s1">&#39;xlo&#39;</span><span class="p">]</span>
            <span class="n">xhi_am</span> <span class="o">=</span> <span class="n">axon_map</span><span class="p">[</span><span class="s1">&#39;xhi&#39;</span><span class="p">]</span>
            <span class="n">ylo_am</span> <span class="o">=</span> <span class="n">axon_map</span><span class="p">[</span><span class="s1">&#39;ylo&#39;</span><span class="p">]</span>
            <span class="n">yhi_am</span> <span class="o">=</span> <span class="n">axon_map</span><span class="p">[</span><span class="s1">&#39;yhi&#39;</span><span class="p">]</span>
            <span class="n">sampling_am</span> <span class="o">=</span> <span class="n">axon_map</span><span class="p">[</span><span class="s1">&#39;sampling&#39;</span><span class="p">]</span>
            <span class="n">axon_lambda_am</span> <span class="o">=</span> <span class="n">axon_map</span><span class="p">[</span><span class="s1">&#39;axon_lambda&#39;</span><span class="p">]</span>

            <span class="k">if</span> <span class="s1">&#39;jan_x&#39;</span> <span class="ow">in</span> <span class="n">axon_map</span> <span class="ow">and</span> <span class="s1">&#39;jan_y&#39;</span> <span class="ow">in</span> <span class="n">axon_map</span><span class="p">:</span>
                <span class="n">jan_x</span> <span class="o">=</span> <span class="n">axon_map</span><span class="p">[</span><span class="s1">&#39;jan_x&#39;</span><span class="p">]</span>
                <span class="n">jan_y</span> <span class="o">=</span> <span class="n">axon_map</span><span class="p">[</span><span class="s1">&#39;jan_y&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">jan_x</span> <span class="o">=</span> <span class="n">jan_y</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># If any of the dimensions don&#39;t match, we need a new retina</span>
            <span class="n">need_new_grid</span> <span class="o">|=</span> <span class="n">xlo</span> <span class="o">!=</span> <span class="n">xlo_am</span>
            <span class="n">need_new_grid</span> <span class="o">|=</span> <span class="n">xhi</span> <span class="o">!=</span> <span class="n">xhi_am</span>
            <span class="n">need_new_grid</span> <span class="o">|=</span> <span class="n">ylo</span> <span class="o">!=</span> <span class="n">ylo_am</span>
            <span class="n">need_new_grid</span> <span class="o">|=</span> <span class="n">yhi</span> <span class="o">!=</span> <span class="n">yhi_am</span>
            <span class="n">need_new_grid</span> <span class="o">|=</span> <span class="n">sampling</span> <span class="o">!=</span> <span class="n">sampling_am</span>
            <span class="n">need_new_grid</span> <span class="o">|=</span> <span class="n">axon_lambda</span> <span class="o">!=</span> <span class="n">axon_lambda_am</span>

            <span class="k">if</span> <span class="s1">&#39;rot&#39;</span> <span class="ow">in</span> <span class="n">axon_map</span><span class="p">:</span>
                <span class="n">rot_am</span> <span class="o">=</span> <span class="n">axon_map</span><span class="p">[</span><span class="s1">&#39;rot&#39;</span><span class="p">]</span>
                <span class="n">need_new_grid</span> <span class="o">|=</span> <span class="n">rot</span> <span class="o">!=</span> <span class="n">rot_am</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Backwards compatibility for older retina object files that</span>
                <span class="c1"># did not have `rot`</span>
                <span class="n">need_new_grid</span> <span class="o">|=</span> <span class="n">rot</span> <span class="o">!=</span> <span class="mi">0</span>

        <span class="c1"># At this point we know whether we need to generate a new retina:</span>
        <span class="k">if</span> <span class="n">need_new_grid</span><span class="p">:</span>
            <span class="n">info_str</span> <span class="o">=</span> <span class="s2">&quot;File &#39;</span><span class="si">%s</span><span class="s2">&#39; doesn&#39;t exist &quot;</span> <span class="o">%</span> <span class="n">filename</span>
            <span class="n">info_str</span> <span class="o">+=</span> <span class="s2">&quot;or has outdated parameter values, generating...&quot;</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">info_str</span><span class="p">)</span>

            <span class="n">jan_x</span><span class="p">,</span> <span class="n">jan_y</span> <span class="o">=</span> <span class="n">jansonius</span><span class="p">(</span><span class="n">rot</span><span class="o">=</span><span class="n">rot</span><span class="p">)</span>
            <span class="n">dva_x</span> <span class="o">=</span> <span class="n">ret2dva</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gridx</span><span class="p">)</span>
            <span class="n">dva_y</span> <span class="o">=</span> <span class="n">ret2dva</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gridy</span><span class="p">)</span>
            <span class="n">ax_id</span><span class="p">,</span> <span class="n">ax_wt</span> <span class="o">=</span> <span class="n">make_axon_map</span><span class="p">(</span><span class="n">dva_x</span><span class="p">,</span> <span class="n">dva_y</span><span class="p">,</span>
                                         <span class="n">jan_x</span><span class="p">,</span> <span class="n">jan_y</span><span class="p">,</span>
                                         <span class="n">axon_lambda</span><span class="o">=</span><span class="n">axon_lambda</span><span class="p">)</span>

            <span class="c1"># Save the variables, together with metadata about the grid:</span>
            <span class="k">if</span> <span class="n">save_data</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span>
                         <span class="n">axon_id</span><span class="o">=</span><span class="n">ax_id</span><span class="p">,</span>
                         <span class="n">axon_weight</span><span class="o">=</span><span class="n">ax_wt</span><span class="p">,</span>
                         <span class="n">jan_x</span><span class="o">=</span><span class="n">jan_x</span><span class="p">,</span>
                         <span class="n">jan_y</span><span class="o">=</span><span class="n">jan_y</span><span class="p">,</span>
                         <span class="n">xlo</span><span class="o">=</span><span class="p">[</span><span class="n">xlo</span><span class="p">],</span>
                         <span class="n">xhi</span><span class="o">=</span><span class="p">[</span><span class="n">xhi</span><span class="p">],</span>
                         <span class="n">ylo</span><span class="o">=</span><span class="p">[</span><span class="n">ylo</span><span class="p">],</span>
                         <span class="n">yhi</span><span class="o">=</span><span class="p">[</span><span class="n">yhi</span><span class="p">],</span>
                         <span class="n">sampling</span><span class="o">=</span><span class="p">[</span><span class="n">sampling</span><span class="p">],</span>
                         <span class="n">axon_lambda</span><span class="o">=</span><span class="p">[</span><span class="n">axon_lambda</span><span class="p">],</span>
                         <span class="n">rot</span><span class="o">=</span><span class="p">[</span><span class="n">rot</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">axon_lambda</span> <span class="o">=</span> <span class="n">axon_lambda</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rot</span> <span class="o">=</span> <span class="n">rot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span> <span class="o">=</span> <span class="n">sampling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axon_id</span> <span class="o">=</span> <span class="n">ax_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axon_weight</span> <span class="o">=</span> <span class="n">ax_wt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jan_x</span> <span class="o">=</span> <span class="n">jan_x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jan_y</span> <span class="o">=</span> <span class="n">jan_y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">range_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridx</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridx</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">range_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridy</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridy</span><span class="o">.</span><span class="n">min</span><span class="p">()</span></div>

<div class="viewcode-block" id="Grid.current2effectivecurrent"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.Grid.current2effectivecurrent">[docs]</a>    <span class="k">def</span> <span class="nf">current2effectivecurrent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Converts a current spread map to an &#39;effective&#39; current spread map, by</span>
<span class="sd">        passing the map through a mapping of axon streaks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cs : array</span>
<span class="sd">            The 2D spread map in retinal space</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ecm : array</span>
<span class="sd">            The effective current spread, a time-series of the same size as the</span>
<span class="sd">            current map, where each pixel is the dot product of the pixel</span>
<span class="sd">            values in ecm along the pixels in the list in axon_map, weighted</span>
<span class="sd">            by the weights axon map.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">cs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cs</span><span class="o">.</span><span class="n">flat</span><span class="p">)):</span>
            <span class="n">ecs</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cs</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axon_id</span><span class="p">[</span><span class="nb">id</span><span class="p">]],</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">axon_weight</span><span class="p">[</span><span class="nb">id</span><span class="p">])</span>

        <span class="c1"># normalize so the response under the electrode in the ecs map</span>
        <span class="c1"># is equal to cs</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span> <span class="o">/</span> <span class="n">ecs</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">cs</span><span class="p">)]</span>
        <span class="n">ecs</span> <span class="o">=</span> <span class="n">ecs</span> <span class="o">*</span> <span class="n">scale</span>

        <span class="c1"># this normalization is based on unit current on the retina producing</span>
        <span class="c1"># a max response of 1 based on axonal integration.</span>
        <span class="c1"># means that response magnitudes don&#39;t change as you increase the</span>
        <span class="c1"># length of axonal integration or sampling of the retina</span>
        <span class="c1"># Doesn&#39;t affect normalization over time, or responses as a function</span>
        <span class="c1"># of the anount of current,</span>

        <span class="k">return</span> <span class="n">ecs</span></div>

<div class="viewcode-block" id="Grid.electrode_ecs"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.Grid.electrode_ecs">[docs]</a>    <span class="k">def</span> <span class="nf">electrode_ecs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">implant</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">14000</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mf">1.69</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gather current spread and effective current spread for each electrode</span>
<span class="sd">        within both the bipolar and the ganglion cell layer</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        implant : implants.ElectrodeArray</span>
<span class="sd">            An implants.ElectrodeArray instance describing the implant.</span>

<span class="sd">        alpha : float</span>
<span class="sd">            Current spread parameter</span>
<span class="sd">        n : float</span>
<span class="sd">            Current spread parameter</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ecs : contains n arrays containing the the effective current</span>
<span class="sd">            spread within various layers</span>
<span class="sd">            for each electrode in the array respectively.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        Electrode.current_spread</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">gridx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                       <span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">implant</span><span class="o">.</span><span class="n">electrodes</span><span class="p">)))</span>
        <span class="n">ecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">gridx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                        <span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">implant</span><span class="o">.</span><span class="n">electrodes</span><span class="p">)))</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">implant</span><span class="o">.</span><span class="n">electrodes</span><span class="p">):</span>
            <span class="n">cs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">current_spread</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gridx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridy</span><span class="p">,</span>
                                             <span class="n">layer</span><span class="o">=</span><span class="s1">&#39;INL&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
            <span class="n">ecs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">cs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">current_spread</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gridx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridy</span><span class="p">,</span>
                                             <span class="n">layer</span><span class="o">=</span><span class="s1">&#39;OFL&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
            <span class="n">ecs</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current2effectivecurrent</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">ecs</span><span class="p">,</span> <span class="n">cs</span></div></div>


<div class="viewcode-block" id="BaseModel"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.BaseModel">[docs]</a><span class="nd">@six</span><span class="o">.</span><span class="n">add_metaclass</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">BaseModel</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Abstract base class for all models of temporal sensitivity.</span>

<span class="sd">    This class provides a standard template for all models of temporal</span>
<span class="sd">    sensitivity.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="BaseModel.set_kwargs"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.BaseModel.set_kwargs">[docs]</a>    <span class="k">def</span> <span class="nf">set_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">warn_inexistent</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Overwrite any given keyword arguments</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        warn_inexistent : bool</span>
<span class="sd">            If True, displays a warning message if a keyword is provided that</span>
<span class="sd">            is not recognized by the temporal model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="ow">and</span> <span class="n">warn_inexistent</span><span class="p">:</span>
                <span class="n">w_s</span> <span class="o">=</span> <span class="s2">&quot;Unknown class attribute &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">key</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">w_s</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseModel.__init__"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.BaseModel.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_kwargs</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseModel.model_cascade"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.BaseModel.model_cascade">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">model_cascade</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_arr</span><span class="p">,</span> <span class="n">pt_list</span><span class="p">,</span> <span class="n">layers</span><span class="p">,</span> <span class="n">use_jit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Abstract base ganglion cell model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        in_arr: array-like</span>
<span class="sd">            A 2D array specifying the effective current values at a particular</span>
<span class="sd">            spatial location (pixel); one value per retinal layer and</span>
<span class="sd">            electrode. Dimensions: &lt;#layers x #electrodes&gt;</span>
<span class="sd">        pt_list : list</span>
<span class="sd">            List of pulse train &#39;data&#39; containers.</span>
<span class="sd">            Dimensions: &lt;#electrodes x #time points&gt;</span>
<span class="sd">        layers : list</span>
<span class="sd">            List of retinal layers to simulate.</span>
<span class="sd">            Choose from:</span>
<span class="sd">            - &#39;OFL&#39;: optic fiber layer</span>
<span class="sd">            - &#39;GCL&#39;: ganglion cell layer</span>
<span class="sd">            - &#39;INL&#39;: inner nuclear layer</span>
<span class="sd">        use_jit : bool</span>
<span class="sd">            If True, applies just-in-time (JIT) compilation to expensive</span>
<span class="sd">            computations for additional speed-up (requires Numba).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

    <span class="c1"># Static attribute</span>
    <span class="n">tsample</span> <span class="o">=</span> <span class="mf">0.005</span> <span class="o">/</span> <span class="mi">1000</span></div>


<div class="viewcode-block" id="Horsager2009"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.Horsager2009">[docs]</a><span class="k">class</span> <span class="nc">Horsager2009</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Model of temporal sensitivity (Horsager et al. 2009)</span>

<span class="sd">    This class implements the model of temporal sensitivty as described in:</span>
<span class="sd">    &gt; A Horsager, SH Greenwald, JD Weiland, MS Humayun, RJ Greenberg,</span>
<span class="sd">    &gt; MJ McMahon, GM Boynton, and I Fine (2009). Predicting visual sensitivity</span>
<span class="sd">    &gt; in retinal prosthesis patients. Investigative Ophthalmology &amp; Visual</span>
<span class="sd">    &gt; Science, 50(4):1483.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tsample : float, optional, default: 0.005 / 1000 seconds</span>
<span class="sd">        Sampling time step (seconds).</span>
<span class="sd">    tau1 : float, optional, default: 0.42 / 1000 seconds</span>
<span class="sd">        Time decay constant for the fast leaky integrater of the ganglion</span>
<span class="sd">        cell layer (GCL).</span>
<span class="sd">    tau2 : float, optional, default: 45.25 / 1000 seconds</span>
<span class="sd">        Time decay constant for the charge accumulation, has values</span>
<span class="sd">        between 38 - 57 ms.</span>
<span class="sd">    tau3 : float, optional, default: 26.25 / 1000 seconds</span>
<span class="sd">        Time decay constant for the slow leaky integrator.</span>
<span class="sd">        Default: 26.25 / 1000 s.</span>
<span class="sd">    epsilon : float, optional, default: 8.73</span>
<span class="sd">        Scaling factor applied to charge accumulation (used to be called</span>
<span class="sd">        epsilon).</span>
<span class="sd">    beta : float, optional, default: 3.43</span>
<span class="sd">        Power nonlinearity applied after half-rectification. The original model</span>
<span class="sd">        used two different values, depending on whether an experiment is at</span>
<span class="sd">        threshold (`beta`=3.43) or above threshold (`beta`=0.83).</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Horsager2009.__init__"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.Horsager2009.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span> <span class="o">=</span> <span class="mf">0.01</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau1</span> <span class="o">=</span> <span class="mf">0.42</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau2</span> <span class="o">=</span> <span class="mf">45.25</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau3</span> <span class="o">=</span> <span class="mf">26.25</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span> <span class="o">=</span> <span class="mf">2.25</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">=</span> <span class="mf">3.43</span>

        <span class="c1"># Overwrite any given keyword arguments, print warning message (True)</span>
        <span class="c1"># if attempting to set an unrecognized keyword</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_kwargs</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma1</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma2</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma3</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span><span class="p">)</span></div>

<div class="viewcode-block" id="Horsager2009.calc_layer_current"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.Horsager2009.calc_layer_current">[docs]</a>    <span class="k">def</span> <span class="nf">calc_layer_current</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_arr</span><span class="p">,</span> <span class="n">pt_list</span><span class="p">,</span> <span class="n">layers</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the effective current map of a given layer</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        in_arr: array-like</span>
<span class="sd">            A 2D array specifying the effective current values</span>
<span class="sd">            at a particular spatial location (pixel); one value</span>
<span class="sd">            per retinal layer and electrode.</span>
<span class="sd">            Dimensions: &lt;#layers x #electrodes&gt;</span>
<span class="sd">        pt_list : list</span>
<span class="sd">            List of pulse train &#39;data&#39; containers.</span>
<span class="sd">            Dimensions: &lt;#electrodes x #time points&gt;</span>
<span class="sd">        layers : list</span>
<span class="sd">            List of retinal layers to simulate.</span>
<span class="sd">            Choose from:</span>
<span class="sd">            - &#39;OFL&#39;: optic fiber layer</span>
<span class="sd">            - &#39;GCL&#39;: ganglion cell layer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;INL&#39;</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The Horsager2009 model does not support an &quot;</span>
                             <span class="s2">&quot;inner nuclear layer.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;GCL&#39;</span> <span class="ow">or</span> <span class="s1">&#39;OFL&#39;</span><span class="p">)</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">:</span>
            <span class="n">ecm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">in_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">pt_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Acceptable values for `layers` are: &#39;GCL&#39;, &quot;</span>
                             <span class="s2">&quot;&#39;OFL&#39;.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ecm</span></div>

<div class="viewcode-block" id="Horsager2009.model_cascade"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.Horsager2009.model_cascade">[docs]</a>    <span class="k">def</span> <span class="nf">model_cascade</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_arr</span><span class="p">,</span> <span class="n">pt_list</span><span class="p">,</span> <span class="n">layers</span><span class="p">,</span> <span class="n">use_jit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Horsager model cascade</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        in_arr: array-like</span>
<span class="sd">            A 2D array specifying the effective current values</span>
<span class="sd">            at a particular spatial location (pixel); one value</span>
<span class="sd">            per retinal layer and electrode.</span>
<span class="sd">            Dimensions: &lt;#layers x #electrodes&gt;</span>
<span class="sd">        pt_list : list</span>
<span class="sd">            List of pulse train &#39;data&#39; containers.</span>
<span class="sd">            Dimensions: &lt;#electrodes x #time points&gt;</span>
<span class="sd">        layers : list</span>
<span class="sd">            List of retinal layers to simulate.</span>
<span class="sd">            Choose from:</span>
<span class="sd">            - &#39;OFL&#39;: optic fiber layer</span>
<span class="sd">            - &#39;GCL&#39;: ganglion cell layer</span>
<span class="sd">        use_jit : bool</span>
<span class="sd">            If True, applies just-in-time (JIT) compilation to</span>
<span class="sd">            expensive computations for additional speed-up</span>
<span class="sd">            (requires Numba).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;INL&#39;</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The Nanduri2012 model does not support an inner &quot;</span>
                             <span class="s2">&quot;nuclear layer.&quot;</span><span class="p">)</span>

        <span class="c1"># Although the paper says to use cathodic-first, the code only</span>
        <span class="c1"># reproduces if we use what we now call anodic-first. So flip the sign</span>
        <span class="c1"># on the stimulus here:</span>
        <span class="n">stim</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_layer_current</span><span class="p">(</span><span class="n">in_arr</span><span class="p">,</span> <span class="n">pt_list</span><span class="p">,</span> <span class="n">layers</span><span class="p">)</span>

        <span class="c1"># R1 convolved the entire stimulus (with both pos + neg parts)</span>
        <span class="n">r1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span> <span class="o">*</span> <span class="n">utils</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">stim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span>
                                       <span class="n">method</span><span class="o">=</span><span class="s1">&#39;sparse&#39;</span><span class="p">)[:</span><span class="n">stim</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>

        <span class="c1"># It&#39;s possible that charge accumulation was done on the anodic phase.</span>
        <span class="c1"># It might not matter too much (timing is slightly different, but the</span>
        <span class="c1"># data are not accurate enough to warrant using one over the other).</span>
        <span class="c1"># Thus use what makes the most sense: accumulate on cathodic</span>
        <span class="n">ca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">stim</span><span class="p">))</span>
        <span class="n">ca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span> <span class="o">*</span> <span class="n">utils</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">ca</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span>
                                       <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fft&#39;</span><span class="p">)[:</span><span class="n">stim</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
        <span class="n">r2</span> <span class="o">=</span> <span class="n">r1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span> <span class="o">*</span> <span class="n">ca</span>

        <span class="c1"># Then half-rectify and pass through the power-nonlinearity</span>
        <span class="n">r3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">r2</span><span class="p">)</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span>

        <span class="c1"># Then convolve with slow gamma</span>
        <span class="n">r4</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span> <span class="o">*</span> <span class="n">utils</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">r3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma3</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span>
                                       <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fft&#39;</span><span class="p">)[:</span><span class="n">stim</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">TimeSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tsample</span><span class="p">,</span> <span class="n">r4</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Nanduri2012"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.Nanduri2012">[docs]</a><span class="k">class</span> <span class="nc">Nanduri2012</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Model of temporal sensitivity (Nanduri et al. 2012)</span>

<span class="sd">    This class implements the model of temporal sensitivity as described in:</span>
<span class="sd">    &gt; Nanduri, Fine, Horsager, Boynton, Humayun, Greenberg, Weiland (2012).</span>
<span class="sd">    &gt; Frequency and Amplitude Modulation Have Different Effects on the Percepts</span>
<span class="sd">    &gt; Elicited by Retinal Stimulation. Investigative Ophthalmology &amp; Visual</span>
<span class="sd">    &gt; Science January 2012, Vol.53, 205-214. doi:10.1167/iovs.11-8401.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tsample : float, optional, default: 0.005 / 1000 seconds</span>
<span class="sd">        Sampling time step (seconds).</span>
<span class="sd">    tau1 : float, optional, default: 0.42 / 1000 seconds</span>
<span class="sd">        Time decay constant for the fast leaky integrater of the ganglion</span>
<span class="sd">        cell layer (GCL).</span>
<span class="sd">    tau2 : float, optional, default: 45.25 / 1000 seconds</span>
<span class="sd">        Time decay constant for the charge accumulation, has values</span>
<span class="sd">        between 38 - 57 ms.</span>
<span class="sd">    tau3 : float, optional, default: 26.25 / 1000 seconds</span>
<span class="sd">        Time decay constant for the slow leaky integrator.</span>
<span class="sd">        Default: 26.25 / 1000 s.</span>
<span class="sd">    eps : float, optional, default: 8.73</span>
<span class="sd">        Scaling factor applied to charge accumulation (used to be called</span>
<span class="sd">        epsilon).</span>
<span class="sd">    asymptote : float, optional, default: 14.0</span>
<span class="sd">        Asymptote of the logistic function used in the stationary</span>
<span class="sd">        nonlinearity stage.</span>
<span class="sd">    slope : float, optional, default: 3.0</span>
<span class="sd">        Slope of the logistic function in the stationary nonlinearity</span>
<span class="sd">        stage.</span>
<span class="sd">    shift : float, optional, default: 16.0</span>
<span class="sd">        Shift of the logistic function in the stationary nonlinearity</span>
<span class="sd">        stage.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Nanduri2012.__init__"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.Nanduri2012.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Set default values of keyword arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau1</span> <span class="o">=</span> <span class="mf">0.42</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau2</span> <span class="o">=</span> <span class="mf">45.25</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau3</span> <span class="o">=</span> <span class="mf">26.25</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="mf">8.73</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">asymptote</span> <span class="o">=</span> <span class="mf">14.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slope</span> <span class="o">=</span> <span class="mf">3.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shift</span> <span class="o">=</span> <span class="mf">16.0</span>

        <span class="c1"># Overwrite any given keyword arguments, print warning message (True)</span>
        <span class="c1"># if attempting to set an unrecognized keyword</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_kwargs</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># perform one-time setup calculations</span>
        <span class="c1"># gamma1 is used for the fast response</span>
        <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma1</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span><span class="p">)</span>

        <span class="c1"># gamma2 is used to calculate charge accumulation</span>
        <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma2</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span><span class="p">)</span>

        <span class="c1"># gamma3 is used to calculate the slow response</span>
        <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma3</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span><span class="p">)</span></div>

<div class="viewcode-block" id="Nanduri2012.calc_layer_current"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.Nanduri2012.calc_layer_current">[docs]</a>    <span class="k">def</span> <span class="nf">calc_layer_current</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_arr</span><span class="p">,</span> <span class="n">pt_list</span><span class="p">,</span> <span class="n">layers</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the effective current map of a given layer</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        in_arr: array-like</span>
<span class="sd">            A 2D array specifying the effective current values</span>
<span class="sd">            at a particular spatial location (pixel); one value</span>
<span class="sd">            per retinal layer and electrode.</span>
<span class="sd">            Dimensions: &lt;#layers x #electrodes&gt;</span>
<span class="sd">        pt_list : list</span>
<span class="sd">            List of pulse train &#39;data&#39; containers.</span>
<span class="sd">            Dimensions: &lt;#electrodes x #time points&gt;</span>
<span class="sd">        layers : list</span>
<span class="sd">            List of retinal layers to simulate.</span>
<span class="sd">            Choose from:</span>
<span class="sd">            - &#39;OFL&#39;: optic fiber layer</span>
<span class="sd">            - &#39;GCL&#39;: ganglion cell layer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;INL&#39;</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The Nanduri2012 model does not support an inner &quot;</span>
                             <span class="s2">&quot;nuclear layer.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;GCL&#39;</span> <span class="ow">or</span> <span class="s1">&#39;OFL&#39;</span><span class="p">)</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">:</span>
            <span class="n">ecm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">in_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">pt_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Acceptable values for `layers` are: &#39;GCL&#39;, &quot;</span>
                             <span class="s2">&quot;&#39;OFL&#39;.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ecm</span></div>

<div class="viewcode-block" id="Nanduri2012.model_cascade"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.Nanduri2012.model_cascade">[docs]</a>    <span class="k">def</span> <span class="nf">model_cascade</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_arr</span><span class="p">,</span> <span class="n">pt_list</span><span class="p">,</span> <span class="n">layers</span><span class="p">,</span> <span class="n">use_jit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Nanduri model cascade</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        in_arr: array-like</span>
<span class="sd">            A 2D array specifying the effective current values</span>
<span class="sd">            at a particular spatial location (pixel); one value</span>
<span class="sd">            per retinal layer and electrode.</span>
<span class="sd">            Dimensions: &lt;#layers x #electrodes&gt;</span>
<span class="sd">        pt_list : list</span>
<span class="sd">            List of pulse train &#39;data&#39; containers.</span>
<span class="sd">            Dimensions: &lt;#electrodes x #time points&gt;</span>
<span class="sd">        layers : list</span>
<span class="sd">            List of retinal layers to simulate.</span>
<span class="sd">            Choose from:</span>
<span class="sd">            - &#39;OFL&#39;: optic fiber layer</span>
<span class="sd">            - &#39;GCL&#39;: ganglion cell layer</span>
<span class="sd">        use_jit : bool</span>
<span class="sd">            If True, applies just-in-time (JIT) compilation to</span>
<span class="sd">            expensive computations for additional speed-up</span>
<span class="sd">            (requires Numba).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;INL&#39;</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The Nanduri2012 model does not support an inner &quot;</span>
                             <span class="s2">&quot;nuclear layer.&quot;</span><span class="p">)</span>

        <span class="c1"># `b1` contains a scaled PulseTrain per layer for this particular</span>
        <span class="c1"># pixel: Use as input to model cascade</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_layer_current</span><span class="p">(</span><span class="n">in_arr</span><span class="p">,</span> <span class="n">pt_list</span><span class="p">,</span> <span class="n">layers</span><span class="p">)</span>

        <span class="c1"># Fast response</span>
        <span class="n">b2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span> <span class="o">*</span> <span class="n">utils</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span>
                                       <span class="n">method</span><span class="o">=</span><span class="s1">&#39;sparse&#39;</span><span class="p">,</span>
                                       <span class="n">use_jit</span><span class="o">=</span><span class="n">use_jit</span><span class="p">)[:</span><span class="n">b1</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>

        <span class="c1"># Charge accumulation</span>
        <span class="n">ca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">b1</span><span class="p">))</span>
        <span class="n">ca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span> <span class="o">*</span> <span class="n">utils</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">ca</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span>
                                       <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fft&#39;</span><span class="p">)[:</span><span class="n">b1</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
        <span class="n">b3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">b2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">*</span> <span class="n">ca</span><span class="p">)</span>

        <span class="c1"># Stationary nonlinearity</span>
        <span class="n">sigmoid</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">expit</span><span class="p">((</span><span class="n">b3</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">slope</span><span class="p">)</span>
        <span class="n">b4</span> <span class="o">=</span> <span class="n">b3</span> <span class="o">*</span> <span class="n">sigmoid</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">asymptote</span>

        <span class="c1"># Slow response</span>
        <span class="n">b5</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span> <span class="o">*</span> <span class="n">utils</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">b4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma3</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span>
                                       <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fft&#39;</span><span class="p">)[:</span><span class="n">b1</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">TimeSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tsample</span><span class="p">,</span> <span class="n">b5</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="TemporalModel"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.TemporalModel">[docs]</a><span class="k">class</span> <span class="nc">TemporalModel</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Latest edition of the temporal sensitivity model (experimental)</span>

<span class="sd">    This class implements the latest version of the temporal sensitivity</span>
<span class="sd">    model (experimental). As such, the model might still change from version</span>
<span class="sd">    to version. For more stable implementations, please refer to other,</span>
<span class="sd">    published models (see `p2p.retina.SUPPORTED_MODELS`).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tsample : float, optional, default: 0.005 / 1000 seconds</span>
<span class="sd">        Sampling time step (seconds).</span>
<span class="sd">    tau_gcl : float, optional, default: 45.25 / 1000 seconds</span>
<span class="sd">        Time decay constant for the fast leaky integrater of the ganglion</span>
<span class="sd">        cell layer (GCL).</span>
<span class="sd">        This is only important in combination with epiretinal electrode</span>
<span class="sd">        arrays.</span>
<span class="sd">    tau_inl : float, optional, default: 18.0 / 1000 seconds</span>
<span class="sd">        Time decay constant for the fast leaky integrater of the inner</span>
<span class="sd">        nuclear layer (INL); i.e., bipolar cell layer.</span>
<span class="sd">        This is only important in combination with subretinal electrode</span>
<span class="sd">        arrays.</span>
<span class="sd">    tau_ca : float, optional, default: 45.25 / 1000 seconds</span>
<span class="sd">        Time decay constant for the charge accumulation, has values</span>
<span class="sd">        between 38 - 57 ms.</span>
<span class="sd">    scale_ca : float, optional, default: 42.1</span>
<span class="sd">        Scaling factor applied to charge accumulation (used to be called</span>
<span class="sd">        epsilon).</span>
<span class="sd">    tau_slow : float, optional, default: 26.25 / 1000 seconds</span>
<span class="sd">        Time decay constant for the slow leaky integrator.</span>
<span class="sd">    scale_slow : float, optional, default: 1150.0</span>
<span class="sd">        Scaling factor applied to the output of the cascade, to make</span>
<span class="sd">        output values interpretable brightness values &gt;= 0.</span>
<span class="sd">    lweight : float, optional, default: 0.636</span>
<span class="sd">        Relative weight applied to responses from bipolar cells (weight</span>
<span class="sd">        of ganglion cells is 1).</span>
<span class="sd">    aweight : float, optional, default: 0.5</span>
<span class="sd">        Relative weight applied to anodic charges (weight of cathodic</span>
<span class="sd">        charges is 1).</span>
<span class="sd">    slope : float, optional, default: 3.0</span>
<span class="sd">        Slope of the logistic function in the stationary nonlinearity</span>
<span class="sd">        stage.</span>
<span class="sd">    shift : float, optional, default: 15.0</span>
<span class="sd">        Shift of the logistic function in the stationary nonlinearity</span>
<span class="sd">        stage.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="TemporalModel.__init__"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.TemporalModel.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Set default values of keyword arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau_gcl</span> <span class="o">=</span> <span class="mf">0.42</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau_inl</span> <span class="o">=</span> <span class="mf">18.0</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau_ca</span> <span class="o">=</span> <span class="mf">45.25</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau_slow</span> <span class="o">=</span> <span class="mf">26.25</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_ca</span> <span class="o">=</span> <span class="mf">42.1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_slow</span> <span class="o">=</span> <span class="mf">1150.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lweight</span> <span class="o">=</span> <span class="mf">0.636</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aweight</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slope</span> <span class="o">=</span> <span class="mf">3.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shift</span> <span class="o">=</span> <span class="mf">15.0</span>

        <span class="c1"># Overwrite any given keyword arguments, print warning message (True)</span>
        <span class="c1"># if attempting to set an unrecognized keyword</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_kwargs</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># perform one-time setup calculations</span>
        <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_inl</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_inl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_gcl</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_gcl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span><span class="p">)</span>

        <span class="c1"># gamma_ca is used to calculate charge accumulation</span>
        <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_ca</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_ca</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span><span class="p">)</span>

        <span class="c1"># gamma_slow is used to calculate the slow response</span>
        <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_slow</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_slow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span><span class="p">)</span></div>

<div class="viewcode-block" id="TemporalModel.fast_response"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.TemporalModel.fast_response">[docs]</a>    <span class="k">def</span> <span class="nf">fast_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stim</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">use_jit</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fast response function</span>

<span class="sd">        Convolve a stimulus `stim` with a temporal low-pass filter `gamma`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stim : array</span>
<span class="sd">           Temporal signal to process, stim(r,t) in Nanduri et al. (2012).</span>
<span class="sd">        use_jit : bool, optional</span>
<span class="sd">           If True (default), use numba just-in-time compilation.</span>
<span class="sd">        usefft : bool, optional</span>
<span class="sd">           If False (default), use sparseconv, else fftconvolve.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Fast response, b2(r,t) in Nanduri et al. (2012).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The function utils.sparseconv can be much faster than np.convolve and</span>
<span class="sd">        signal.fftconvolve if `stim` is sparse and much longer than the</span>
<span class="sd">        convolution kernel.</span>
<span class="sd">        The output is not converted to a TimeSeries object for speedup.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">conv</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">stim</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                          <span class="n">use_jit</span><span class="o">=</span><span class="n">use_jit</span><span class="p">)</span>

        <span class="c1"># Cut off the tail of the convolution to make the output signal</span>
        <span class="c1"># match the dimensions of the input signal.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span> <span class="o">*</span> <span class="n">conv</span><span class="p">[:</span><span class="n">stim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span></div>

<div class="viewcode-block" id="TemporalModel.charge_accumulation"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.TemporalModel.charge_accumulation">[docs]</a>    <span class="k">def</span> <span class="nf">charge_accumulation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ecm</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the charge accumulation</span>

<span class="sd">        Charge accumulation is calculated on the effective input current</span>
<span class="sd">        `ecm`, as opposed to the output of the fast response stage.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ecm : array-like</span>
<span class="sd">            A 2D array specifying the effective current values at a particular</span>
<span class="sd">            spatial location (pixel); one value per retinal layer, averaged</span>
<span class="sd">            over all electrodes through that pixel.</span>
<span class="sd">            Dimensions: &lt;#layers x #time points&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ca</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">ecm</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ca</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">summed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ecm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]))</span>
            <span class="n">conved</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span> <span class="o">*</span> <span class="n">utils</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">summed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_ca</span><span class="p">,</span>
                                               <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fft&#39;</span><span class="p">)</span>
            <span class="n">ca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_ca</span> <span class="o">*</span> <span class="n">conved</span><span class="p">[:</span><span class="n">ecm</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">ca</span></div>

<div class="viewcode-block" id="TemporalModel.stationary_nonlinearity"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.TemporalModel.stationary_nonlinearity">[docs]</a>    <span class="k">def</span> <span class="nf">stationary_nonlinearity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stim</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Stationary nonlinearity</span>

<span class="sd">        Nonlinearly rescale a temporal signal `stim` across space and time,</span>
<span class="sd">        based on a sigmoidal function dependent on the maximum value of `stim`.</span>
<span class="sd">        This is Box 4 in Nanduri et al. (2012).</span>
<span class="sd">        The parameter values of the asymptote, slope, and shift of the logistic</span>
<span class="sd">        function are given by self.asymptote, self.slope, and self.shift,</span>
<span class="sd">        respectively.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stim : array</span>
<span class="sd">           Temporal signal to process, stim(r,t) in Nanduri et al. (2012).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Rescaled signal, b4(r,t) in Nanduri et al. (2012).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Conversion to TimeSeries is avoided for the sake of speedup.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># use expit (logistic) function for speedup</span>
        <span class="n">sigmoid</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">expit</span><span class="p">((</span><span class="n">stim</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">slope</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stim</span> <span class="o">*</span> <span class="n">sigmoid</span></div>

<div class="viewcode-block" id="TemporalModel.slow_response"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.TemporalModel.slow_response">[docs]</a>    <span class="k">def</span> <span class="nf">slow_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stim</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Slow response function</span>

<span class="sd">        Convolve a stimulus `stim` with a low-pass filter (3-stage gamma)</span>
<span class="sd">        with time constant self.tau_slow.</span>
<span class="sd">        This is Box 5 in Nanduri et al. (2012).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stim : array</span>
<span class="sd">           Temporal signal to process, stim(r,t) in Nanduri et al. (2012)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Slow response, b5(r,t) in Nanduri et al. (2012).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is by far the most computationally involved part of the perceptual</span>
<span class="sd">        sensitivity model.</span>
<span class="sd">        Conversion to TimeSeries is avoided for the sake of speedup.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># No need to zero-pad: fftconvolve already takes care of optimal</span>
        <span class="c1"># kernel/data size</span>
        <span class="n">conv</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">stim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_slow</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fft&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)</span>

        <span class="c1"># Cut off the tail of the convolution to make the output signal match</span>
        <span class="c1"># the dimensions of the input signal.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_slow</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span> <span class="o">*</span> <span class="n">conv</span><span class="p">[:</span><span class="n">stim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span></div>

<div class="viewcode-block" id="TemporalModel.calc_layer_current"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.TemporalModel.calc_layer_current">[docs]</a>    <span class="k">def</span> <span class="nf">calc_layer_current</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ecs_item</span><span class="p">,</span> <span class="n">pt_list</span><span class="p">,</span> <span class="n">layers</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;For a given pixel, calculates the effective current for each retinal</span>
<span class="sd">           layer over time</span>

<span class="sd">        This function operates at a single-pixel level: It calculates the</span>
<span class="sd">        combined current from all electrodes through a spatial location</span>
<span class="sd">        over time. This calculation is performed per retinal layer.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ecs_item: array-like</span>
<span class="sd">            A 2D array specifying the effective current values at a</span>
<span class="sd">            particular spatial location (pixel); one value per retinal</span>
<span class="sd">            layer and electrode.</span>
<span class="sd">            Dimensions: &lt;#layers x #electrodes&gt;</span>
<span class="sd">        pt_list: list</span>
<span class="sd">            A list of PulseTrain `data` containers.</span>
<span class="sd">            Dimensions: &lt;#electrodes x #time points&gt;</span>
<span class="sd">        layers : list</span>
<span class="sd">            List of retinal layers to simulate. Choose from:</span>
<span class="sd">            - &#39;OFL&#39;: optic fiber layer</span>
<span class="sd">            - &#39;GCL&#39;: ganglion cell layer</span>
<span class="sd">            - &#39;INL&#39;: inner nuclear layer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">not_supported</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">l</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">SUPPORTED_LAYERS</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">],</span>
                                 <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">not_supported</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Acceptable values for `layers` is &#39;OFL&#39;, &#39;GCL&#39;, &quot;</span>
                             <span class="s2">&quot;&#39;INL&#39;.&quot;</span><span class="p">)</span>

        <span class="n">ecm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ecs_item</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="s1">&#39;INL&#39;</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">:</span>
            <span class="n">ecm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ecs_item</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">pt_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;GCL&#39;</span> <span class="ow">or</span> <span class="s1">&#39;OFL&#39;</span><span class="p">)</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">:</span>
            <span class="n">ecm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ecs_item</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">pt_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ecm</span></div>

<div class="viewcode-block" id="TemporalModel.model_cascade"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.TemporalModel.model_cascade">[docs]</a>    <span class="k">def</span> <span class="nf">model_cascade</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ecs_item</span><span class="p">,</span> <span class="n">pt_list</span><span class="p">,</span> <span class="n">layers</span><span class="p">,</span> <span class="n">use_jit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The Temporal Sensitivity model</span>

<span class="sd">        This function applies the model of temporal sensitivity to a single</span>
<span class="sd">        retinal cell (i.e., a pixel). The model is inspired by Nanduri</span>
<span class="sd">        et al. (2012), with some extended functionality.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ecs_item: array-like</span>
<span class="sd">            A 2D array specifying the effective current values at a particular</span>
<span class="sd">            spatial location (pixel); one value per retinal layer and</span>
<span class="sd">            electrode.</span>
<span class="sd">            Dimensions: &lt;#layers x #electrodes&gt;</span>
<span class="sd">        pt_list: list</span>
<span class="sd">            A list of PulseTrain `data` containers.</span>
<span class="sd">            Dimensions: &lt;#electrodes x #time points&gt;</span>
<span class="sd">        layers : list</span>
<span class="sd">            List of retinal layers to simulate. Choose from:</span>
<span class="sd">            - &#39;OFL&#39;: optic fiber layer</span>
<span class="sd">            - &#39;GCL&#39;: ganglion cell layer</span>
<span class="sd">            - &#39;INL&#39;: inner nuclear layer</span>
<span class="sd">        use_jit : bool</span>
<span class="sd">            If True, applies just-in-time (JIT) compilation to expensive</span>
<span class="sd">            computations for additional speed-up (requires Numba).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Brightness response over time. In Nanduri et al. (2012), the</span>
<span class="sd">        maximum value of this signal was used to represent the perceptual</span>
<span class="sd">        brightness of a particular location in space, B(r).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># For each layer in the model, scale the pulse train data with the</span>
        <span class="c1"># effective current:</span>
        <span class="n">ecm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_layer_current</span><span class="p">(</span><span class="n">ecs_item</span><span class="p">,</span> <span class="n">pt_list</span><span class="p">,</span> <span class="n">layers</span><span class="p">)</span>

        <span class="c1"># Calculate charge accumulation on the input</span>
        <span class="n">ca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">charge_accumulation</span><span class="p">(</span><span class="n">ecm</span><span class="p">)</span>

        <span class="c1"># Sparse convolution is faster if input is sparse. This is true for</span>
        <span class="c1"># the first convolution in the cascade, but not for subsequent ones.</span>
        <span class="k">if</span> <span class="s1">&#39;INL&#39;</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">:</span>
            <span class="n">fr_inl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fast_response</span><span class="p">(</span><span class="n">ecm</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_inl</span><span class="p">,</span>
                                        <span class="n">use_jit</span><span class="o">=</span><span class="n">use_jit</span><span class="p">,</span>
                                        <span class="n">method</span><span class="o">=</span><span class="s1">&#39;sparse&#39;</span><span class="p">)</span>

            <span class="c1"># Cathodic and anodic parts are treated separately: They have the</span>
            <span class="c1"># same charge accumulation, but anodic currents contribute less to</span>
            <span class="c1"># the response</span>
            <span class="n">fr_inl_cath</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">fr_inl</span><span class="p">)</span>
            <span class="n">fr_inl_anod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aweight</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">fr_inl</span><span class="p">)</span>
            <span class="n">resp_inl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">fr_inl_cath</span> <span class="o">+</span> <span class="n">fr_inl_anod</span> <span class="o">-</span> <span class="n">ca</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">resp_inl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">ecm</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;GCL&#39;</span> <span class="ow">or</span> <span class="s1">&#39;OFL&#39;</span><span class="p">)</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">:</span>
            <span class="n">fr_gcl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fast_response</span><span class="p">(</span><span class="n">ecm</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_gcl</span><span class="p">,</span>
                                        <span class="n">use_jit</span><span class="o">=</span><span class="n">use_jit</span><span class="p">,</span>
                                        <span class="n">method</span><span class="o">=</span><span class="s1">&#39;sparse&#39;</span><span class="p">)</span>

            <span class="c1"># Cathodic and anodic parts are treated separately: They have the</span>
            <span class="c1"># same charge accumulation, but anodic currents contribute less to</span>
            <span class="c1"># the response</span>
            <span class="n">fr_gcl_cath</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">fr_gcl</span><span class="p">)</span>
            <span class="n">fr_gcl_anod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aweight</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">fr_gcl</span><span class="p">)</span>
            <span class="n">resp_gcl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">fr_gcl_cath</span> <span class="o">+</span> <span class="n">fr_gcl_anod</span> <span class="o">-</span> <span class="n">ca</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">resp_gcl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">ecm</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">resp</span> <span class="o">=</span> <span class="n">resp_gcl</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lweight</span> <span class="o">*</span> <span class="n">resp_inl</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stationary_nonlinearity</span><span class="p">(</span><span class="n">resp</span><span class="p">)</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slow_response</span><span class="p">(</span><span class="n">resp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">TimeSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tsample</span><span class="p">,</span> <span class="n">resp</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ret2dva"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.ret2dva">[docs]</a><span class="k">def</span> <span class="nf">ret2dva</span><span class="p">(</span><span class="n">r_um</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts retinal distances (um) to visual angles (deg)</span>

<span class="sd">    This function converts an eccentricity measurement on the retinal</span>
<span class="sd">    surface (in micrometers), measured from the optic axis, into degrees</span>
<span class="sd">    of visual angle.</span>
<span class="sd">    Source: Eq. A6 in Watson (2014), J Vis 14(7):15, 1-17</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">r_um</span><span class="p">)</span>
    <span class="n">r_mm</span> <span class="o">=</span> <span class="mf">1e-3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">r_um</span><span class="p">)</span>
    <span class="n">r_deg</span> <span class="o">=</span> <span class="mf">3.556</span> <span class="o">*</span> <span class="n">r_mm</span> <span class="o">+</span> <span class="mf">0.05993</span> <span class="o">*</span> <span class="n">r_mm</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mf">0.007358</span> <span class="o">*</span> <span class="n">r_mm</span> <span class="o">**</span> <span class="mi">3</span>
    <span class="n">r_deg</span> <span class="o">+=</span> <span class="mf">3.027e-4</span> <span class="o">*</span> <span class="n">r_mm</span> <span class="o">**</span> <span class="mi">4</span>
    <span class="k">return</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">r_deg</span></div>


<div class="viewcode-block" id="micron2deg"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.micron2deg">[docs]</a><span class="nd">@utils</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="n">alt_func</span><span class="o">=</span><span class="s1">&#39;p2p.retina.ret2dva&#39;</span><span class="p">,</span> <span class="n">deprecated_version</span><span class="o">=</span><span class="s1">&#39;0.2&#39;</span><span class="p">,</span>
                  <span class="n">removed_version</span><span class="o">=</span><span class="s1">&#39;0.3&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">micron2deg</span><span class="p">(</span><span class="n">micron</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Transforms a distance from microns to degrees</span>

<span class="sd">    Based on http://retina.anatomy.upenn.edu/~rob/lance/units_space.html</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">deg</span> <span class="o">=</span> <span class="n">micron</span> <span class="o">/</span> <span class="mf">280.0</span>
    <span class="k">return</span> <span class="n">deg</span></div>


<div class="viewcode-block" id="deg2micron"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.deg2micron">[docs]</a><span class="nd">@utils</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="n">alt_func</span><span class="o">=</span><span class="s1">&#39;p2p.retina.dva2ret&#39;</span><span class="p">,</span> <span class="n">deprecated_version</span><span class="o">=</span><span class="s1">&#39;0.2&#39;</span><span class="p">,</span>
                  <span class="n">removed_version</span><span class="o">=</span><span class="s1">&#39;0.3&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">deg2micron</span><span class="p">(</span><span class="n">deg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Transforms a distance from degrees to microns</span>

<span class="sd">    Based on http://retina.anatomy.upenn.edu/~rob/lance/units_space.html</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">microns</span> <span class="o">=</span> <span class="mf">280.0</span> <span class="o">*</span> <span class="n">deg</span>
    <span class="k">return</span> <span class="n">microns</span></div>


<div class="viewcode-block" id="dva2ret"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.dva2ret">[docs]</a><span class="k">def</span> <span class="nf">dva2ret</span><span class="p">(</span><span class="n">r_deg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts visual angles (deg) into retinal distances (um)</span>

<span class="sd">    This function converts a retinal distancefrom the optic axis (um)</span>
<span class="sd">    into degrees of visual angle.</span>
<span class="sd">    Source: Eq. A5 in Watson (2014), J Vis 14(7):15, 1-17</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">r_deg</span><span class="p">)</span>
    <span class="n">r_deg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">r_deg</span><span class="p">)</span>
    <span class="n">r_mm</span> <span class="o">=</span> <span class="mf">0.268</span> <span class="o">*</span> <span class="n">r_deg</span> <span class="o">+</span> <span class="mf">3.427e-4</span> <span class="o">*</span> <span class="n">r_deg</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mf">8.3309e-6</span> <span class="o">*</span> <span class="n">r_deg</span> <span class="o">**</span> <span class="mi">3</span>
    <span class="n">r_um</span> <span class="o">=</span> <span class="mf">1e3</span> <span class="o">*</span> <span class="n">r_mm</span>
    <span class="k">return</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">r_um</span></div>


<div class="viewcode-block" id="jansonius"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.jansonius">[docs]</a><span class="k">def</span> <span class="nf">jansonius</span><span class="p">(</span><span class="n">num_cells</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">801</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">15</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span>
              <span class="n">rot</span><span class="o">=</span><span class="mi">0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bs</span><span class="o">=-</span><span class="mf">1.9</span><span class="p">,</span> <span class="n">bi</span><span class="o">=.</span><span class="mi">5</span><span class="p">,</span> <span class="n">r0</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
              <span class="n">max_samples</span><span class="o">=</span><span class="mi">45</span><span class="p">,</span> <span class="n">ang_range</span><span class="o">=</span><span class="mi">60</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Implements the model of retinal axonal pathways by generating a</span>
<span class="sd">    matrix of (x,y) positions.</span>

<span class="sd">    Assumes that the fovea is at [0, 0]</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    num_cells : int</span>
<span class="sd">        Number of axons (cells).</span>
<span class="sd">    num_samples : int</span>
<span class="sd">        Number of samples per axon (spatial resolution).</span>
<span class="sd">    Center: 2 item array</span>
<span class="sd">        The location of the optic disk in dva.</span>

<span class="sd">    See:</span>

<span class="sd">    Jansonius et al., 2009, A mathematical description of nerve fiber bundle</span>
<span class="sd">    trajectories and their variability in the human retina, Vision Research</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Default parameters:</span>
    <span class="c1">#</span>
    <span class="c1"># r0 = 4;             %Minumum radius (optic disc size)</span>
    <span class="c1">#</span>
    <span class="c1"># center = [15,2];    %p.center of optic disc</span>
    <span class="c1">#</span>
    <span class="c1"># rot = 0*pi/180;    %Angle of rotation (clockwise)</span>
    <span class="c1"># scale = 1;             %Scale factor</span>
    <span class="c1">#</span>
    <span class="c1"># bs = -1.9;          %superior &#39;b&#39; parameter constant</span>
    <span class="c1"># bi = .5;            %inferior &#39;c&#39; parameter constant</span>
    <span class="c1"># ang_range = 60</span>

    <span class="n">ang0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">ang_range</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="n">num_cells</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
                      <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span> <span class="n">ang_range</span><span class="p">,</span> <span class="n">num_cells</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)])</span>

    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">r0</span><span class="p">,</span> <span class="n">max_samples</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">)</span>
    <span class="c1"># generate angle and radius matrices from vectors with meshgrid</span>
    <span class="n">ang0mat</span><span class="p">,</span> <span class="n">rmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">ang0</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>

    <span class="n">num_samples</span> <span class="o">=</span> <span class="n">ang0mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">num_cells</span> <span class="o">=</span> <span class="n">ang0mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># index into superior (upper) axons</span>
    <span class="n">sup</span> <span class="o">=</span> <span class="n">ang0mat</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="c1"># Set up &#39;b&#39; parameter:</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">num_cells</span><span class="p">])</span>

    <span class="n">b</span><span class="p">[</span><span class="n">sup</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
        <span class="n">bs</span> <span class="o">+</span> <span class="mf">3.9</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">ang0mat</span><span class="p">[</span><span class="n">sup</span><span class="p">]</span> <span class="o">-</span> <span class="mi">121</span><span class="p">)</span> <span class="o">/</span> <span class="mi">14</span><span class="p">))</span>  <span class="c1"># equation 5</span>
    <span class="c1"># equation 6</span>
    <span class="n">b</span><span class="p">[</span><span class="o">~</span><span class="n">sup</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">bi</span> <span class="o">+</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="o">-</span><span class="n">ang0mat</span><span class="p">[</span><span class="o">~</span><span class="n">sup</span><span class="p">]</span> <span class="o">-</span> <span class="mi">90</span><span class="p">)</span> <span class="o">/</span> <span class="mi">25</span><span class="p">))</span>

    <span class="c1"># Set up &#39;c&#39; parameter:</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">num_cells</span><span class="p">])</span>

    <span class="c1"># equation 3 (fixed typo)</span>
    <span class="n">c</span><span class="p">[</span><span class="n">sup</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.9</span> <span class="o">+</span> <span class="mf">1.4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">((</span><span class="n">ang0mat</span><span class="p">[</span><span class="n">sup</span><span class="p">]</span> <span class="o">-</span> <span class="mi">121</span><span class="p">)</span> <span class="o">/</span> <span class="mi">14</span><span class="p">)</span>
    <span class="n">c</span><span class="p">[</span><span class="o">~</span><span class="n">sup</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="o">.</span><span class="mi">5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">((</span><span class="o">-</span><span class="n">ang0mat</span><span class="p">[</span><span class="o">~</span><span class="n">sup</span><span class="p">]</span> <span class="o">-</span> <span class="mi">90</span><span class="p">)</span> <span class="o">/</span> <span class="mi">25</span><span class="p">)</span>   <span class="c1"># equation 4</span>

    <span class="c1"># %Here&#39;s the main function: spirals as a function of r (equation 1)</span>
    <span class="n">ang</span> <span class="o">=</span> <span class="n">ang0mat</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="p">(</span><span class="n">rmat</span> <span class="o">-</span> <span class="n">r0</span><span class="p">)</span><span class="o">**</span><span class="n">c</span>

    <span class="c1"># Transform to x-y coordinates</span>
    <span class="n">xprime</span> <span class="o">=</span> <span class="n">rmat</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ang</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">)</span>
    <span class="n">yprime</span> <span class="o">=</span> <span class="n">rmat</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ang</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">)</span>

    <span class="c1"># Find where the fibers cross the horizontal meridian</span>
    <span class="n">cross</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">num_cells</span><span class="p">])</span>
    <span class="n">cross</span><span class="p">[</span><span class="n">sup</span><span class="p">]</span> <span class="o">=</span> <span class="n">yprime</span><span class="p">[</span><span class="n">sup</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span>
    <span class="n">cross</span><span class="p">[</span><span class="o">~</span><span class="n">sup</span><span class="p">]</span> <span class="o">=</span> <span class="n">yprime</span><span class="p">[</span><span class="o">~</span><span class="n">sup</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="c1"># Set Nans to axon paths after crossing horizontal meridian</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">cross</span><span class="p">))</span>

    <span class="n">curr_col</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nb">id</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>  <span class="c1"># loop through axons</span>
        <span class="k">if</span> <span class="n">curr_col</span> <span class="o">!=</span> <span class="nb">id</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">yprime</span><span class="p">[</span><span class="nb">id</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]:,</span> <span class="nb">id</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
            <span class="n">curr_col</span> <span class="o">=</span> <span class="nb">id</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

    <span class="c1"># Bend the image according to (the inverse) of Appendix A</span>
    <span class="n">xmodel</span> <span class="o">=</span> <span class="n">xprime</span> <span class="o">+</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ymodel</span> <span class="o">=</span> <span class="n">yprime</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">xprime</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ymodel</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">yprime</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">+</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">xmodel</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">/</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>

    <span class="c1">#  rotate about the optic disc and scale</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">scale</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">rot</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">xmodel</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">rot</span><span class="p">)</span> <span class="o">*</span>
                 <span class="p">(</span><span class="n">ymodel</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">+</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">scale</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">rot</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">xmodel</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">rot</span><span class="p">)</span> <span class="o">*</span>
                 <span class="p">(</span><span class="n">ymodel</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">+</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span></div>


<div class="viewcode-block" id="make_axon_map"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.make_axon_map">[docs]</a><span class="k">def</span> <span class="nf">make_axon_map</span><span class="p">(</span><span class="n">xg</span><span class="p">,</span> <span class="n">yg</span><span class="p">,</span> <span class="n">jan_x</span><span class="p">,</span> <span class="n">jan_y</span><span class="p">,</span> <span class="n">axon_lambda</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">min_weight</span><span class="o">=.</span><span class="mi">001</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Retinal axon map</span>

<span class="sd">    Generates a mapping of how each pixel in the retina space is affected</span>
<span class="sd">    by stimulation of underlying ganglion cell axons.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xg, yg : array</span>
<span class="sd">        meshgrid of pixel locations in units of visual angle sp</span>
<span class="sd">    axon_lambda : float</span>
<span class="sd">        space constant for how effective stimulation (or &#39;weight&#39;) falls off</span>
<span class="sd">        with distance from the pixel back along the axon toward the optic disc</span>
<span class="sd">        (default 1 degree)</span>
<span class="sd">    min_weight : float</span>
<span class="sd">        minimum weight falloff.  default .001</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    axon_id : list</span>
<span class="sd">        a list, for every pixel, of the index into the pixel in xg,yg space,</span>
<span class="sd">        along the underlying axonal pathway.</span>
<span class="sd">    axon_weight : list</span>
<span class="sd">        a list, for every pixel, of the axon weight into the pixel in xg,yg</span>
<span class="sd">        space</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># initialize tuples</span>
    <span class="n">axon_xg</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">axon_yg</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">axon_dist</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">axon_weight</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">axon_id</span> <span class="o">=</span> <span class="p">()</span>

    <span class="c1"># loop through pixels as indexed into a single dimension</span>
    <span class="k">for</span> <span class="n">px</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xg</span><span class="o">.</span><span class="n">flat</span><span class="p">)):</span>
        <span class="c1"># find the nearest axon to this pixel</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">jan_x</span> <span class="o">-</span> <span class="n">xg</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">px</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">jan_y</span> <span class="o">-</span> <span class="n">yg</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">px</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">cur_ax_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>  <span class="c1"># index into the current axon</span>
        <span class="p">[</span><span class="n">ax_pos_id0</span><span class="p">,</span> <span class="n">ax_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">cur_ax_id</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">dist</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">cur_xg</span> <span class="o">=</span> <span class="n">xg</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">px</span><span class="p">]</span>
        <span class="n">cur_yg</span> <span class="o">=</span> <span class="n">yg</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">px</span><span class="p">]</span>

        <span class="c1"># add first values to the list for this pixel</span>
        <span class="n">axon_dist</span> <span class="o">=</span> <span class="n">axon_dist</span> <span class="o">+</span> <span class="p">([</span><span class="mi">0</span><span class="p">],)</span>
        <span class="n">axon_weight</span> <span class="o">=</span> <span class="n">axon_weight</span> <span class="o">+</span> <span class="p">([</span><span class="mi">1</span><span class="p">],)</span>
        <span class="n">axon_xg</span> <span class="o">=</span> <span class="n">axon_xg</span> <span class="o">+</span> <span class="p">([</span><span class="n">cur_xg</span><span class="p">],)</span>
        <span class="n">axon_yg</span> <span class="o">=</span> <span class="n">axon_yg</span> <span class="o">+</span> <span class="p">([</span><span class="n">cur_yg</span><span class="p">],)</span>
        <span class="n">axon_id</span> <span class="o">=</span> <span class="n">axon_id</span> <span class="o">+</span> <span class="p">([</span><span class="n">px</span><span class="p">],)</span>

        <span class="c1"># now loop back along this nearest axon toward the optic disc</span>
        <span class="k">for</span> <span class="n">ax_pos_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ax_pos_id0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="c1"># increment the distance from the starting point</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="p">(</span><span class="n">jan_x</span><span class="p">[</span><span class="n">ax_pos_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ax_num</span><span class="p">]</span> <span class="o">-</span> <span class="n">jan_x</span><span class="p">[</span><span class="n">ax_pos_id</span><span class="p">,</span> <span class="n">ax_num</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">ay</span> <span class="o">=</span> <span class="p">(</span><span class="n">jan_y</span><span class="p">[</span><span class="n">ax_pos_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ax_num</span><span class="p">]</span> <span class="o">-</span> <span class="n">jan_y</span><span class="p">[</span><span class="n">ax_pos_id</span><span class="p">,</span> <span class="n">ax_num</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">dist</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ax</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">ay</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

            <span class="c1"># weight falls off exponentially as distance from axon cell body</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dist</span> <span class="o">/</span> <span class="n">axon_lambda</span><span class="p">)</span>

            <span class="c1"># find the nearest pixel to the current position along the axon</span>
            <span class="n">dist_xg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">xg</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">jan_x</span><span class="p">[</span><span class="n">ax_pos_id</span><span class="p">,</span> <span class="n">ax_num</span><span class="p">])</span>
            <span class="n">dist_yg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">yg</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">jan_y</span><span class="p">[</span><span class="n">ax_pos_id</span><span class="p">,</span> <span class="n">ax_num</span><span class="p">])</span>
            <span class="n">nearest_xg_id</span> <span class="o">=</span> <span class="n">dist_xg</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
            <span class="n">nearest_yg_id</span> <span class="o">=</span> <span class="n">dist_yg</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
            <span class="n">nearest_xg</span> <span class="o">=</span> <span class="n">xg</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">nearest_xg_id</span><span class="p">]</span>
            <span class="n">nearest_yg</span> <span class="o">=</span> <span class="n">yg</span><span class="p">[</span><span class="n">nearest_yg_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

            <span class="c1"># if the position along the axon has moved to a new pixel, and the</span>
            <span class="c1"># weight isn&#39;t too small...</span>
            <span class="k">if</span> <span class="n">weight</span> <span class="o">&gt;</span> <span class="n">min_weight</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nearest_xg</span> <span class="o">!=</span> <span class="n">cur_xg</span> <span class="ow">or</span> <span class="n">nearest_yg</span> <span class="o">!=</span> <span class="n">cur_yg</span><span class="p">:</span>
                    <span class="c1"># update the current pixel location</span>
                    <span class="n">cur_xg</span> <span class="o">=</span> <span class="n">nearest_xg</span>
                    <span class="n">cur_yg</span> <span class="o">=</span> <span class="n">nearest_yg</span>

                    <span class="c1"># append the list</span>
                    <span class="n">axon_weight</span><span class="p">[</span><span class="n">px</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">weight</span><span class="p">))</span>
                    <span class="n">axon_id</span><span class="p">[</span><span class="n">px</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">((</span><span class="n">nearest_yg_id</span><span class="p">,</span>
                                                             <span class="n">nearest_xg_id</span><span class="p">),</span>
                                                            <span class="n">xg</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">axon_id</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">axon_weight</span><span class="p">)</span></div>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Michael Beyeler, Ariel Rokem, Geoff Boynton, and Ione Fine, The University of Washington.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.2.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>